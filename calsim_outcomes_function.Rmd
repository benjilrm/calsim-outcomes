
Refer to [project overview](https://docs.google.com/document/d/1QPh7cKy7fmokalWuou5Z_zqG6680rybq8CC6gmiC8RE/edit?tab=t.0) document for guidance

# Set up

Import packages
```{r}
suppressPackageStartupMessages({
  suppressWarnings({
  library(tidyverse)   # Data wrangling
  library(here)        # File management
  library(readxl)      # Read excel files
  })})
```

Set settings and universal variables
```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = here())

options(scipen = 999)
```

# Crosswalk data
Crosswalk between demand units' demand ID and delivery ID
Provided by Kristin via [this folder](https://drive.google.com/drive/folders/1BYFQlIA0JJ31sAHDt7yMovLWWZvwoMeO)
```{r}
crosswalk = read_excel("Inputs/Master crosswalk SW DUs M&I.xlsx")%>%
  rename(dwuc = 1, demand_id = 2, delivery_id = 3)
```

# Demand and delivery data

Demand and delivery data downloaded from the respective Google Drive folder linked to each scenario in [this spreadsheet](https://docs.google.com/spreadsheets/d/1iXqEc4sMVC8gKqPzhf_VOS32EXKzocAP2pNJ5PZlFbY/edit?gid=0#gid=0). Once in a scenario's folder, click on 'Data Extraction', then 'Demands_Deliveries'. We want to download csvs of monthly values for both demand and deliveries.

Function to extract scenario ID from filename
```{r}
extract_scenario_id = function(filename) {
  str_extract(filename, "s\\d+") %>% tolower()}
```

# Processing functions

## Process individual file

Core function to process either a demand or delivery file. 

Cleans up header rows, extracts values for demand or delivery (in TAF), and pivots longer so we have 1 row per demand unit per month (rather than 1 column per demand unit, which is how the raw data is structured). Filters for only demand units whose demand ID or delivery ID is in our crosswalk dataset

Returns a processed dataset of either demand or delivery values by demand unit and month
```{r}
process_file = function(file_path, crosswalk, data_type = c("demand", "delivery")) {
  data_type = match.arg(data_type)
  scenario_id = extract_scenario_id(basename(file_path))
  
  # Read and clean the data
  data = read.csv(file_path) %>%
    mutate(row_id = row_number())%>%
    pivot_longer(cols = -row_id,
                 names_to = "col_position",
                 values_to = "value")%>%
    pivot_wider(
      names_from = row_id,
      values_from = value)%>%
    rename(
      col_position = 1,
      demand_unit_id = 2,    
      units = 7)
  
  dates = data%>%
    slice(1) %>%  
    select(8:ncol(.)) %>%
    pivot_longer(
      cols = everything(),
      names_to = "date_id",
      values_to = "date")
  
  # Filter for only demand units whose demand ID or delivery ID is in our crosswalk dataset
  # Convert any blank values to NA
  id_col = ifelse(data_type == "demand", "demand_id", "delivery_id")
  value_col = ifelse(data_type == "demand", "demand_taf", "delivery_taf")
  
  processed = data%>%
    filter(units == "TAF" & demand_unit_id %in% crosswalk[[id_col]])%>%
    select(-c(1,3:units))%>%
    pivot_longer(
      cols = -demand_unit_id,
      names_to = "date_id",
      values_to = "value_taf")%>%
    left_join(dates, by = "date_id")%>%
    select(-date_id)%>%
    mutate(scenario_id = scenario_id,
           value_taf = as.numeric(ifelse(value_taf == "", NA, value_taf)))
  
  # Rename columns based on data type and return processed dataset
  if (data_type == "demand") {
    processed = processed %>%
      rename(demand_id = demand_unit_id, demand_taf = value_taf) %>%
      select(scenario_id, demand_id, date, demand_taf) %>%
      left_join(crosswalk%>%select(dwuc, demand_id), by = "demand_id")} 
  else {
    processed = processed %>%
      rename(delivery_id = demand_unit_id, delivery_taf = value_taf) %>%
      select(scenario_id, delivery_id, date, delivery_taf) %>%
      left_join(crosswalk%>%select(dwuc, delivery_id), by = "delivery_id")}
  
  # Get the actual column name that was created
  actual_id_col = ifelse(data_type == "demand", "demand_id", "delivery_id")
  actual_value_col = ifelse(data_type == "demand", "demand_taf", "delivery_taf")
  
  # Create list of missing units - FIXED
  not_present = crosswalk %>%
    select(all_of(id_col)) %>%  # Use the original id_col name
    distinct() %>%
    mutate(status = ifelse(!.data[[id_col]] %in% processed[[actual_id_col]], 
                           "Not in data", NA)) %>%
    filter(!is.na(status))
  
  # Check if all values are either 0 or NA - FIXED
  all_blank_or_all_zero = processed %>%
    group_by(.data[[actual_id_col]]) %>%
    reframe(
      status = case_when(
        all(is.na(.data[[actual_value_col]])) ~ "All blank", 
        all(.data[[actual_value_col]] == 0, na.rm = T) ~ "All zero", 
        T ~ NA)) %>%
    ungroup() %>%
    filter(!is.na(status))
  
  missing = bind_rows(not_present, all_blank_or_all_zero) %>%
    mutate(scenario_id = scenario_id)
  
  return(list(processed = processed, missing = missing))}
```

```{r}
process_file("Inputs/Deliveries/s0011_adjBL_wTUCP_DELIVERIES.csv", crosswalk, "delivery")$missing
```


## Process complete scenario

Main function to process a complete scenario (demand + delivery pair):

Goes through the demand and delivery folders to identify scenarios, and if both files found for a given scenario, calls the function above to process both the demand and delivery data. 

Creates a dataset of missing demand units for that scenario and writes to a csv for each scenario.

Joins demand and delivery data by demand unit ID and filters out rows with any missing values. Calculates monthly % of demand met and writes to a csv

Aggregates demand and delivery by year for each demand unit and calculates annual % of demand met. Saves this to a csv for each scenario as well

Calculates tiers based on annual % of demand met
```{r}
process_scenario = function(scenario_id, demand_folder, delivery_folder, crosswalk, output_base = "Outputs") {
  cat("Processing scenario:", scenario_id, "\n")
  
  # Find files for this scenario
  demand_files = list.files(demand_folder, pattern = paste0(scenario_id, ".*\\.csv$"), full.names = TRUE)
  delivery_files = list.files(delivery_folder, pattern = paste0(scenario_id, ".*\\.csv$"), full.names = TRUE)
  
  # Process both files
  demand_data = process_file(demand_files[1], crosswalk, "demand")$processed
  delivery_data = process_file(delivery_files[1], crosswalk, "delivery")$processed
  
  missing_demand = process_file(demand_files[1], crosswalk, "demand")$missing
  missing_delivery = process_file(delivery_files[1], crosswalk, "delivery")$missing
  
  # Combine and filter data
  combined_monthly = full_join(delivery_data, demand_data, by = c("dwuc", "date", "scenario_id"))%>%
    filter(!demand_id %in% missing_demand$demand_id & !delivery_id %in% missing_delivery$delivery_id)%>%
    mutate(
      demand_taf = as.numeric(ifelse(is.na(demand_taf), 0, demand_taf)),
      delivery_taf = as.numeric(ifelse(is.na(delivery_taf), 0, delivery_taf)),
      percent_demand_met = ifelse(delivery_taf >= demand_taf, 100, delivery_taf / demand_taf * 100),
      year = year(date))%>%
    select(scenario_id, dwuc, date, year, delivery_id, delivery_taf, demand_id, demand_taf, percent_demand_met)
  
  # Save monthly data
  if (!is.null(output_base)) {
    monthly_dir = file.path(output_base, "Monthly demand met")
    dir.create(monthly_dir, showWarnings = FALSE, recursive = TRUE)
    write.csv(combined_monthly, file.path(monthly_dir, paste0(scenario_id, "_demand_met_by_month.csv")), row.names = FALSE)}
  
  # Calculate annual aggregates
  combined_by_year = combined_monthly %>%
    group_by(scenario_id, year, dwuc) %>%
    reframe(
      annual_delivery = sum(delivery_taf),
      annual_demand = sum(demand_taf)) %>%
    ungroup() %>%
    mutate(
      percent_demand_met = ifelse(annual_delivery >= annual_demand, 100, annual_delivery / annual_demand * 100))
  
  # Save annual data 
  if (!is.null(output_base)) {
    annual_dir = file.path(output_base, "Annual demand met")
    dir.create(annual_dir, showWarnings = FALSE, recursive = TRUE)
    write.csv(combined_by_year, file.path(annual_dir, paste0(scenario_id, "_demand_met_by_year.csv")), row.names = FALSE)}
  
  # Calculate tiers
  tiers = combined_by_year %>%
    mutate(percent_demand_met = round(percent_demand_met),
      demand_met = ifelse(percent_demand_met >= 90, 1, 0)) %>%
    group_by(scenario_id, dwuc) %>%
    reframe(
      perc_years_met = mean(demand_met, na.rm = T) * 100,
      min_met = min(percent_demand_met)) %>%
    ungroup() %>%
    mutate(
      tier = case_when(
        perc_years_met >= 90 & min_met > 70 ~ 1,
        perc_years_met >= 70 & min_met > 70 ~ 2,
        perc_years_met >= 50 & min_met > 50 ~ 3,
        T ~ 4)) %>%
    select(scenario_id, dwuc, tier)
  
  return(list(tiers = tiers, missing_demand = missing_demand, missing_delivery = missing_delivery))}
```

## Process all scenarios

Last function to go through the demand and delivery folders, pull out all the files, and calls upon the function above to process each scenario and generate the corresponding outputs. 

Extracts the tier categorisations for each scenario and combines it into one matrix containing tier values across all scenarios and demand units, following the example in [this folder](https://drive.google.com/drive/folders/1PMgwXjWK0eHX_2Zac4_QNrA_BaFZNpF0). 
Saves the master tier matrix as a csv
```{r}
# Process ALL scenarios and create tier matrix
process_all_scenarios = function(demand_folder, delivery_folder, crosswalk, output_base = "Outputs") {
  
  # Get scenario IDs
  demand_files = list.files(demand_folder, pattern = "\\.csv$")
  delivery_files = list.files(delivery_folder, pattern = "\\.csv$")
  
  demand_scenarios = sapply(demand_files, extract_scenario_id)
  delivery_scenarios = sapply(delivery_files, extract_scenario_id)
  common_scenarios = intersect(demand_scenarios, delivery_scenarios)
  
  cat("Found", length(common_scenarios), "scenarios to process\n\n")
  
  # Process each scenario and collect results
  all_results = map(common_scenarios, function(scenario_id) {
    process_scenario(scenario_id, demand_folder, delivery_folder, crosswalk, output_base)})
  
  # Extract tiers from all results and combine
  all_tiers = map_df(all_results, ~ .x$tiers)
  
  # Extract missing data from all results and combine
  all_missing_demand = map_df(all_results, ~ .x$missing_demand)%>%
    pivot_wider(names_from = scenario_id, values_from = status)%>%
    arrange(demand_id)
  all_missing_delivery = map_df(all_results, ~ .x$missing_delivery)%>%
    pivot_wider(names_from = scenario_id, values_from = status)%>%
    arrange(delivery_id)
  
  # Convert to matrix format
  tier_matrix = all_tiers %>%
    pivot_wider(
      names_from = dwuc,
      values_from = tier,
      names_sort = T)%>%
    arrange(scenario_id)
  
  # Save tier outputs
  if (!is.null(output_base)) {
    tier_dir = file.path(output_base, "Tier summaries")
    dir.create(tier_dir, showWarnings = F, recursive = T)
    write.csv(tier_matrix, file.path(tier_dir, "all_scenarios_tier_matrix.csv"), row.names = F)}
  
  # Save master missing values file
  missing_dir = file.path(output_base, "Missing demand units")
  dir.create(missing_dir, showWarnings = F, recursive = T)
  write.csv(all_missing_demand, file.path(missing_dir, "all_scenarios_missing_demand.csv"), row.names = F)
  write.csv(all_missing_delivery, file.path(missing_dir, "all_scenarios_missing_delivery.csv"), row.names = F)}
```

# Run functions

Specify demand and delivery folders as inputs, as well as crosswalk sheet with key to connect demand unit ID, demand-specific ID, and delivery-specific ID. 
Specify folder where outputs will be saved
```{r}
results = process_all_scenarios(
  demand_folder = "Inputs/Demands",
  delivery_folder = "Inputs/Deliveries",
  crosswalk = crosswalk,
  output_base = "Outputs")  # Set to NULL if you don't want intermediate files saved
```


```{r}
read.csv("Outputs/Missing demand units/all_scenarios_missing_demand.csv")
read.csv("Outputs/Missing demand units/all_scenarios_missing_delivery.csv")


```








